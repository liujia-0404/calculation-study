##hashMap:
   ###1、分析
    
         1、之所以速度快，因为它使用的是散列表，根据 key 的 hashcode 值生成数组下标（通过内存地址直接查找，没有任何判断），
         时间复杂度完美情况下可以达到 n1（和数组相同，但是比数组用着爽多了，但是需要多出很多内存，相当于以空间换时间）。
         
         2、在当我们对HashMap初始化没设置初始化容量时，系统会默认创建一个容量为16的大小的集合。若我们的所需的集合很小则会造成内存浪费，
         而当HashMap的容量值超过了临界值（threshold)时HashMap将会重新扩容的下一个2的指数幂（16->32）。HashMap扩容将会重新创建hash表降低性能。
         
  ###2、如何设置一个合理的初始化容量
         当我们使用HashMap(int initialCapacity)来初始化容量的时候，jdk会默认帮我们计算一个相对合理的值当做初始容量。
         当HashMap的容量值超过了临界值（threshold)时就会扩容，threshold = HashMap的容量值*0.75，比如初始化容量为8的
         HashMap当大小达到8*0.75=6时将会扩容到16。当我们设置HashMap的初始化容量是遵循expectedSize /0.75+1，
         比如expectedSize是6时 6/0.75+1=9，此时jdk处理后会被设置成16，大大降低了HashMap被扩容的几率。